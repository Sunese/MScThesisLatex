\section{Problem statement}
Structure editors provide a way to manipulate the abstract syntax structure of a program directly, in contrast to writing and editing the source code of a program in plain text, which also requires a parser to produce an abstract syntax tree. An early example of this is shown by Reps and Teitelbaum\cite{timtom84} in 1984.
By using a structure editor, the user can avoid syntax errors and might have a better overview of their source code. Moreover, unfinished blocks of code can be represented by syntactic holes, allowing the programmer to develop a mental model of their code, without getting distracted or blocked by syntax errors.

% How is the project trying to solve it
This project will implement a generalized type-safe structure editor, based on a proposed calculus\cite{aalborg}.

% What are the criteria for a good solution
The criteria for a good solution are the following:

\begin{itemize}
    \item The user can edit the abstract syntax from any program directly
    \item The editor is generic, in the sense that it can handle the syntax of any language, not limited to programming languages
    \item The editor can handle context-sensitive syntax, specifically binding mechanisms
    \item The editor supports multiple views of the code being edited, such as a tree-view or a pretty-printed program based on the language's concrete syntax
    \item The user should be able to specify the abstract and concrete syntax of any language in a non-challenging way
\end{itemize}

% What are the criteria for a minimal viable product
The implementation relies on a proposed syntax-directed editor calculus\cite{aalborg} which promises to be language-independent and able to handle binding mechanisms. Hence, a minimal solution should fulfil the first two criteria, where a user can edit an AST directly (i.e. it is a structure editor) and the editor is generic, while the ability to handle context-sensitive syntax is crucial, yet not indispensable.

% What are good examples?
Since this project will propose a generic editor, it is crucial to provide a meaningful set of concrete examples, demonstrating that the solution is indeed generic and can be used for any language.
This project will attempt to provide a meaningful set of concrete examples in a non-biased manner, with languages (or subsets thereof) of different paradigms and purposes.

%The set of examples should contain one or more popular general-purpose programming languages of different paradigms and have a distinctive syntax from the other examples in the set. 
The set of examples should contain one or more popular general-purpose programming languages.
All examples should have a clear syntactic distinction, to exclude dialects of the same language and otherwise very similar languages. \\ GitHub provides a top 30 ranking\cite{prog-lang-metrics} by number of unique \texttt{git} pushes with a given programming language on their platform, and this project will consider entries in the chart of popular character.

Usage of the editor is not limited to programming languages, hence the set of examples should also contain one or more domain-specific languages and markup languages suitable for structure editing, in the sense that it contains declarations and binders.

% What examples will the project show? 
Based on prior criteria, the project will provide examples for subsets of the following languages:
\begin{itemize}
    \item C
    \item SQL
    \item \LaTeX
\end{itemize}

The C language\cite{c-iso-standard} is a popular general-purpose programming language deemed as a good candidate because of it being an imperative language, which stands in contrast to recent works on structure editors\cite{aalborg}\cite{godiksen}\cite{omar} that primarily focus on functional languages. The \texttt{C} programming language also has a strict and symbol-rich concrete syntax, which can easily lead to ill-formed programs when editing a \texttt{C} program in plain text. Consider \cref{ex:c-ill-form-prog} for an example.

\begin{myfigure}{Ill-formed C program}{ex:c-ill-form-prog}
    Below is an example of a C program that at first glance looks well-formed, but will be rejected because of a missing semicolon at line 4:
    \begin{lstlisting}[style=figurestyle]
int main() {
    int x = 0;
    for (int i; i = 0; i++) {
        x++
    }
    return 0;
}
    \end{lstlisting}
\end{myfigure}

The SQL language is a popular language deemed as a good candidate, because of it being a declarative language that also provides a contrast to both functional and imperative languages. There exist many dialects of SQL and for the sake of completeness, this project will refer to the PostgreSQL\cite{postgresql-about} variant in any SQL context. Different dialects, including PostgreSQL, have a strict syntax in common, which can also easily lead to ill-formed programs when editing in plain text. Consider \cref{fig:sql-ill-formed} for an example.

\begin{myfigure}{Ill-formed SQL query}{fig:sql-ill-formed}
    Below is an example of a PostgreSQL query which is ill-formed because of a missing comma in line 1 and wrong use of the equality operator in line 2:
    \begin{lstlisting}[style=figurestyle]
SELECT col-a col-b FROM table
WHERE col-a == 'x';
\end{lstlisting}
\end{myfigure}

\LaTeX\cite{latex-about} is a markup language suitable for structure editing, which provides a contrast to the already-picked examples since it is not considered a programming language. \LaTeX\ is suitable for structure editing
as documents often involve complex structures with nested environments and commands, which can be cumbersome to manage in plain text. A structure editor can significantly simplify the process of creating and managing these complex documents by providing a more intuitive interface.
