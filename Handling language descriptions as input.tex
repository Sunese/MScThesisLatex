\documentclass{article}
\usepackage[toc,page]{appendix}
\usepackage{blindtext}
\usepackage{titlesec}
\usepackage{graphicx} % Required for inserting images
\usepackage{float}
\usepackage[ddmmyyyy,hhmmss]{datetime}
\usepackage{listings}% http://ctan.org/pkg/listings
\usepackage{amsmath}
\usepackage[a4paper, total={6in, 10in}]{geometry}
\usepackage{hyperref}
\usepackage{biblatex}
\usepackage[dvipsnames]{xcolor}
\usepackage{parskip}
\usepackage{luacolor} % Required to use the lua-ul \highLight command 
\usepackage{lua-ul} 
\usepackage{lmodern}
\usepackage[most]{tcolorbox}
\usepackage{varwidth}   %% provides varwidth environment

\colorlet{mycolor}{teal!80!blue}
\tcbset{
    enhanced,
    colback=mycolor!5!white,
    boxrule=0.1pt,
    colframe=mycolor!80!white,
    fonttitle=\bfseries
}

\newtcolorbox[blend into=figures]{myfigure}[3][]{title={#2},#1,hbox,label={#3}}

\addbibresource{references/ref.bib}

\hypersetup{
    colorlinks=true,
    linkcolor=cyan,
    citecolor=cyan,
    filecolor=magenta,      
    urlcolor=cyan,
    pdftitle={Overleaf Example},
    pdfpagemode=FullScreen
}
\LuaULSetHighLightColor{yellow}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\setlength{\parindent}{0pt} % No indentation
\title{Handling language specification input \\ V4}
\date{\today}
\author{Sune Skaanning Engtorp}

\begin{document}
\maketitle

\section{Definition of abstract syntax}


\section{How to represent the abstract syntax from the user's perspective}

The generalized editor calculus\cite{aalborg} assumes that it is given an abstract syntax that is represented by a set of sorts $\mathcal{S}$, an arity-indexed family of operators $\mathcal{O}$, and a sort-indexed family of variables $\mathcal{X}$, as per Robert Harper's notation \cite{practical-foundations-for-prog-lang}.

It can be a challenge from the user's perspective to provide a specification based on what the calculus assumes. Therefore, it is ideal for the implementation to provide other means of describing the syntax of a language.

In terms of early examples, Metal\cite{metal} has been used in the Mentor \cite{mentor-applications} and CENTAUR \cite{centaur} systems.

Another example with the same purpose is Zephyr ASDL (Abstract Syntax Description Language)\cite{zephyr}.

Another example is ASN.1 (Abstract Syntax Notation One)\cite{asn1}, with its primary use in telecommunication and cryptography.

However, it is also possible to define a specification language for the to-be-implemented generalized editor itself, which can assist the user in describing the syntax. This would also require a parser that can parse the necessary information assumed by the calculus. Picking this route allows the project to avoid spending time on analyzing different tools and arguing which is the best among them for this use-case.

An example for such a specification language, describing a very simple language for basic arithmetic is provided in figure \ref{fig:arith-ex}.

\begin{center}
\begin{myfigure}{Description of a simple language syntax}{fig:arith-ex}
\begin{varwidth}{\textwidth}
\[ e \in Exp \]
\[ n \in Num \]

\[ e ::= \quad n \quad | \quad e_1 + e_2 \quad | \quad e_1 * e_2 \]
\end{varwidth}
\end{myfigure}
\end{center}

% \begin{lstlisting}[caption={Description of a simple language syntax},label={lst:arith-ex}]
% e in Exp
% n in Num

% e ::= n | e_1 + e_2 | e_1 * e_2
% \end{lstlisting}

The specification language first expects some syntactic categories and then derivation rules with BNF notation.

The specification language itself can be described with BNF notation (with some informal notation for newlines and strings), as seen in figure \ref{fig:spec-lang-bnf}.

% \begin{lstlisting}[caption={Description of the language itself},label={lst:spec-lang-bnf}]
% syntax      ::= category rule
% category    ::= term ' in ' term '\n' category | '\n' 
% rule        ::= term ' ::=' exp '\n' rule | EOF
% exp         ::= ' | ' <any-string> exp | 
% term        ::= <alpha-numeric-string>
% \end{lstlisting}

\begin{center}
\begin{myfigure}{Description of the language itself}{fig:spec-lang-bnf}
\begin{varwidth}{\textwidth}
\begin{align*}
syntax &::= category \ rule &&\\
category &::= term \ `\in\textrm' \ term \ \text{<EOL>} \ category \ | \text{<EOL>} &&\\
rule &::= term \ `::=\textrm' \ exp \ \text{<EOL>} \ rule \ | \ \text{<EOL>} &&\\
exp &::= `|\textrm' \ \text{<any-string>} \ exp \ | &&\\
term &::= \text{<alpha-numeric-string>}
\end{align*}
\end{varwidth}
\end{myfigure}
\end{center}

From this specification language it is possible to extract a set of sorts $\mathcal{S}$, which is every given syntactic category. For example, $e \in Exp$ can get parsed into a sort $s_{e}$.

The arity-indexed operators can be extracted from the BNF notation. For example, the expression $n$ (right-hand side) for the symbol $e$ (left-hand side) can be parsed into an operator $o_n$ with arity $(s_n)s_e$, since we know what syntactic category the expression is part of (hence also the sort) and we know what syntactic category the symbol is part of. 

With operators taking multiple arguments of the same sort, it is expected that each argument has a number subscript. E.g. the $e_1 + e_2$ expression for the $e$ symbol can be parsed to an operator $o_+$ with arity $(s_e, s_e)s_e$.

The rules for the generalized editor calculus\cite{aalborg} are based on the modification of abstract binding trees (abt's), which would add more complexity to the current version of the specification language, if supported. This is because the current specification language cannot know if an expression has any binders for some expression variable. For example, there may exist an operator $let$ in the abstract syntax within the syntactic category of $s$, which is expressed as $let \  x = e \ in \ s$.
% \begin{lstlisting}
% let x = e in s
% \end{lstlisting}
If following Harper's notation\cite{practical-foundations-for-prog-lang}, the $let$ operator would have arity $(e,s)s$ in an abstract syntax tree (ast), while it would have arity $(e,e.s)s$ in an abt, to indicate that the second $e$ is a binder that binds a variable $e$ within $s$.

% \highLight{
% Although it is an inconvenience not being provided with binding-related information, in terms of strictly following the generalized editor calculus\cite{aalborg}, the main focus of this project is to implement a generalized editor. For this reason, the scope of this project will narrow down slightly on the generalized part of the editor calculus\cite{aalborg}, and drop support the context-sensitive aspects. This is, however, done with the intent of possibly extending the scope in order to support context-sensitive aspects, hence taking all findings of the generalized editor calculus into consideration.
% }

\printbibliography

\end{document}